Two arrays:
One for breakable bricks. Each element of array contains the object brick.
Second for unbreakable bricks.

Array of balls
Array of collectibles available
Array of falling_collectibles
Active collectible
numberOfLeft
numberOfRight
activeBullets
collectedCollectible
var Caught

Class Vector: x,y
product

fn Sum: for vector sum

Class Brick: It has position of brick, dimensions, life of brick, color,
render, => (bool)collision_with_ball(ball){reduce life by one, ball_direction_change() if life is 0, (we can return0 ) }

Class Ball: speed,position, dimension, color,
render,updatePos, throwTheBall(), updateSpeedX(), reverseSpeedY(bool), slowSpeed(), normalSpeed(), caught()

Class Throw_Direction: pos1(same as pos of ball),pos2(other end)
render,moveLeft(), moveRight()

Class Paddle{Should have slanting edges}: bool Bullet, size, position, color, catch_count, stepDistance()
render(wrap),collision_with_ball(ball,Dir,n){check for catch_count,and call corr fn in ball}, fastStepSpeed(), normalStepSpeed(), move(left(1)/right(-1), wrap), longLenght(), normalLength(), shortLength(), shootBullet(), collecting()

Class Bullet: speed,pos,color,dimension
render(),release(),updatePos()

Class enclosed_Collectible: type, Brick_index
(type)release()

Class falling_Collectible: position,speed, type, dimension, color
render(),reach_bottom()

Life lost when no ball left on screen.

In the fn being updated, if(Brick[i].collision_with_ball(ball) is called){call collectibles fn.=> Then use type and make a falling_Collectible of that type}.